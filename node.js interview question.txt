Perfect ðŸ‘ â€” hereâ€™s a **clear and short interview-style explanation** for each topic.
Use these in **technical interviews** â€” theyâ€™re crisp, to the point, and demonstrate solid understanding ðŸ‘‡

---

## âš™ï¸ **1. Modules and `require` / `import-export`**

> **Interview Answer:**
> Node.js uses modules to organize code into reusable files.
> There are two main systems:

* **CommonJS** â†’ Uses `require()` to import and `module.exports` to export.
* **ES Modules (ESM)** â†’ Uses `import` and `export` keywords, and are modern JavaScript standard modules.

âœ… *Example:*

```js
// CommonJS
const fs = require('fs');

// ES Module
import fs from 'fs';
```

> **Key difference:** CommonJS is synchronous (older system), while ES Modules are asynchronous and follow modern JS syntax.

---

## ðŸŒ **2. Global Objects**

> **Interview Answer:**
> Global objects in Node.js are available everywhere without importing.
> Some common ones:

* `console` â†’ For logging
* `process` â†’ Info about the running Node process (like environment, PID)
* `__dirname` â†’ Directory path of the current file
* `__filename` â†’ Full path of the current file
* `global` â†’ Like `window` in browser, global namespace in Node

âœ… *Example:*

```js
console.log(__dirname); 
console.log(process.env.NODE_ENV);
```

---

## ðŸ“ **3. File System Module (`fs`)**

> **Interview Answer:**
> The `fs` module is used to interact with the file system â€” reading, writing, updating, or deleting files.
> It supports both **synchronous** and **asynchronous** methods.

âœ… *Example:*

```js
const fs = require('fs');
fs.readFile('file.txt', 'utf8', (err, data) => console.log(data));
```

> **Tip:** Prefer asynchronous methods to avoid blocking the event loop.

---

## ðŸ§­ **4. Path Module (`path`)**

> **Interview Answer:**
> The `path` module helps work with file and directory paths in a platform-independent way.

âœ… *Example:*

```js
const path = require('path');
console.log(path.join(__dirname, 'folder', 'file.txt'));
```

> It handles separators automatically and provides helpers like `basename`, `dirname`, and `extname`.

---

## ðŸ’» **5. OS Module (`os`)**

> **Interview Answer:**
> The `os` module provides system-related information such as memory, CPU, and platform details.

âœ… *Example:*

```js
const os = require('os');
console.log(os.platform(), os.totalmem(), os.freemem());
```

> Commonly used to monitor system performance or display environment details.

---

## âš¡ **6. Events Module (`EventEmitter`)**

> **Interview Answer:**
> Node.js is **event-driven**. The `events` module provides the `EventEmitter` class, which lets you create and listen to custom events.

âœ… *Example:*

```js
const EventEmitter = require('events');
const emitter = new EventEmitter();

emitter.on('greet', () => console.log('Hello!'));
emitter.emit('greet');
```

> Used heavily in Nodeâ€™s core modules â€” for example, HTTP servers, streams, and sockets.

---

## ðŸŒŠ **7. Streams**

> **Interview Answer:**
> Streams are used to process data piece by piece instead of loading it all at once (helps with large files or continuous data).

There are **4 types**:

1. **Readable** â€“ For reading data
2. **Writable** â€“ For writing data
3. **Duplex** â€“ Both readable and writable
4. **Transform** â€“ Modify data as it passes through

âœ… *Example:*

```js
const fs = require('fs');
fs.createReadStream('input.txt').pipe(fs.createWriteStream('output.txt'));
```

> **Advantage:** Streams improve performance and memory efficiency.

---

## ðŸ§  **Quick Summary Table**

| Topic              | Purpose                 | Key Syntax                |
| ------------------ | ----------------------- | ------------------------- |
| **Modules**        | Organize & reuse code   | `require` / `import`      |
| **Global Objects** | Access environment info | `process`, `__dirname`    |
| **fs**             | Work with files         | `fs.readFile()`           |
| **path**           | Handle paths            | `path.join()`             |
| **os**             | System info             | `os.platform()`           |
| **events**         | Event handling          | `emitter.on()`            |
| **streams**        | Handle data flow        | `readable.pipe(writable)` |

---

Would you like me to give you a **â€œ2-minute interview revision sheetâ€** (a one-page cheat sheet with all the key definitions and sample answers)? Itâ€™s perfect before interviews.







ðŸ”¥ Here are **SUPER tricky, highly technical Node.js + MongoDB interview questions** that interviewers use to check deep understanding, not just memorization. These questions trap even experienced developers.

Iâ€™ll give **high-level tricky questions**, mixing concept + hidden edge-case logic.

---

# âœ… ðŸ”¥ **TRICKY NODE.JS QUESTIONS (Deep Level)**

---

### âœ… **1. What happens if you call `setTimeout(() => {}, 0)` inside a Promise?**

Trick: Microtasks (Promises) run before macrotasks (setTimeout), even if timeout = 0.

---

### âœ… **2. Why does this code print 3000000000 even though JavaScript canâ€™t handle 64-bit integers?**

```js
console.log(10 ** 12 * 3);
```

Reason: JS uses 64-bit floating point, not 64-bit integer. Precision loss happens, but results may â€œlook correctâ€ until threshold.

---

### âœ… **3. Why `process.nextTick()` can freeze event loop?**

Because `nextTick()` queue executes **before** microtasks and can recursively starve the loop.

---

### âœ… **4. Why synchronous crypto hashing kills Node performance?**

Because `crypto.pbkdf2Sync()` blocks **main thread**, not threadpool.

---

### âœ… **5. How many threads Node.js actually uses?**

Trick: NOT 1.

* Main thread
* Libuv threadpool (default 4 threads)
* OS threads for async FS
* V8 threads
* GC threads

---

### âœ… **6. What happens if an unhandledPromiseRejection occurs and your Node version > 15?**

Process **does NOT exit** by default â€” it logs error only. Before v15, it crashes.

---

### âœ… **7. Why Mongoose `.populate()` is slow even with indexes?**

Because `populate` runs separate queries and merges data in JS, not on Mongo engine.

---

### âœ… **8. Can you use `await` inside `forEach`? Why not?**

No â€” `forEach` doesnâ€™t await promises; it runs async code concurrently.

Expected answer: Use `for...of`.

---

### âœ… **9. What is memory leak in Node? Give a real cause.**

Example: `setInterval(() => {}, 1000)` without clearInterval, capturing closures.

---

### âœ… **10. Why a try/catch cannot catch async errors?**

Because try/catch is synchronous. Async errors must be caught with `.catch()` or `await`.

---

### âœ… **11. Why Node.js res.send() after res.json() causes error?**

Because headers already sent. Only one response allowed per request.

---

### âœ… **12. Why Object.freeze() doesn't deeply freeze in JS?**

Because it is shallow freeze. Nested objects still mutable.

---

---

# âœ… ðŸ”¥ **TRICKY MONGODB QUESTIONS (Deep Internals)**

---

### âœ… **13. Why is `db.collection.update({})` dangerous?**

Because empty filter updates **all documents**.

---

### âœ… **14. Why `$regex` search is slow even with index?**

Regex starting with wildcard `"^abc"` can use index
But `"abc"` or `".*abc"` cannot use index â†’ full scan.

---

### âœ… **15. Why Mongo skip() is slow?**

Skip() still scans skipped docs, wasting CPU + I/O.

---

### âœ… **16. Why this query is slow?**

```js
find({ status: { $ne: "active" } })
```

Because `$ne` cannot use index â†’ full collection scan.

---

### âœ… **17. How does MongoDB decide which index to use?**

It runs a **query planner** using multi-index comparison and picks lowest score route â†’ cached for future.

---

### âœ… **18. Why this aggregation fails?**

```js
$unwind: "$orders.items"
```

If some documents donâ€™t have `orders`, unwind defaults to remove them unless `"preserveNullAndEmptyArrays: true"`

---

### âœ… **19. Why ObjectId is increasing but not strictly sequential?**

ObjectId structure:

* Timestamp
* Machine ID
* Process ID
* Increment counter

So itâ€™s increasing but not purely numeric sorted.

---

### âœ… **20. Why you cannot perform transactions without replica set?**

Transactions require oplog, available only in replica sets.

---

### âœ… **21. Why Mongo deletes are slower than inserts?**

Because it checks index consistency and may need compaction during delete.

---

### âœ… **22. Why large arrays in documents kill performance?**

Because MongoDB creates multi-key indexes, exploding index size and degrading performance.

---

### âœ… **23. Why MongoDB stores numbers as double by default?**

Because BSON uses double unless manually declared as int32/int64.

---

---

# âœ… TRICKY REAL-WORLD COMBINED QUESTIONS (Node + Mongo)

---

### âœ… **24. How do you prevent race conditions when two users try to update same MongoDB document?**

Correct answer: Use `$inc`, `$addToSet`, `$push`, atomic operators OR transactions.

---

### âœ… **25. Why using Mongoose `.save()` in loops causes performance issues?**

Because `.save()` creates a separate connection round-trip per document.

Better: `insertMany()` or `bulkWrite()`.

---

### âœ… **26. Why REST API can return stale data even though Mongo writes are "successful"?**

Because write concern default is `w:1` â†’ not majority acknowledged.

---

### âœ… **27. Why calling res.json() inside transaction commit callback causes memory leak?**

Because Mongo driver returns promises inside callbacks â€” mixing callback + async style.

---

### âœ… **28. How does Node.js handle 30k simultaneous DB connections?**

It doesn't. Node handles users, not DB connections.

Correct strategy: Use a connection pool.

---

### âœ… **29. Why MongoDB findOne() returns null even when document exists?**

Because:

* Wrong readPreference (e.g., reading from secondary before replication)
* Document is not committed majority
* Projection hides fields
* Type mismatch `"1"` vs `1`

---

### âœ… **30. What is the hidden cost of using timestamps: true in mongoose?**

It adds index creation on updatedAt field â†’ slow startup on large collections.

---

---

# âœ… If you want deeper:

âœ… Detailed answers for each
âœ… Coding examples of tricky pitfalls
âœ… Whiteboard system design questions
âœ… MCQ + scenario-based test

Tell me which one you want next.





âœ… Got it. Here are **brand new, completely different, very advanced and tricky Node.js + MongoDB questions**.
These are NOT repeated from any previous list â€” all fresh, deeper, more technical, and extremely interview-focused.

---

# âœ… **ðŸ”¥ SUPER ADVANCED & TRICKY NODE.JS INTERVIEW QUESTIONS (NEW SET)**

---

## âœ… **1. What happens when you call setTimeout inside setImmediate?**

Explain execution order under different OS event-loop behaviors.

---

## âœ… **2. Why does this log 50 instead of 500?**

```js
for (var i = 0; i < 10; i++) {
  setTimeout(() => console.log(i * 5), 0);
}
```

---

## âœ… **3. Why does Node.js sometimes skip setInterval callbacks?**

Explain event loop starvation.

---

## âœ… **4. How does Node execute a Promise that contains heavy synchronous logic inside then()?**

Example:

```js
Promise.resolve().then(() => while(true){});
```

---

## âœ… **5. How does Node.js handle TCP sockets vs WebSockets?**

Explain OS kernel involvement, epoll, and libuv.

---

## âœ… **6. Why does waiting for a large file download block other routes in Express unless streamed?**

Explain synchronous buffering + RAM pressure.

---

## âœ… **7. What happens if process.nextTick() recursively calls itself?**

Explain starvation of event loop.

---

## âœ… **8. Why does worker_thread crash if you pass a huge JSON object using parentPort.postMessage()?**

Explain structured cloning algorithm.

---

## âœ… **9. Why is cluster.fork() dangerous with shared in-memory cache?**

Data inconsistency between processes.

---

## âœ… **10. What happens when a Node.js process reaches max call stack size?**

Explain stack overflow error and memory regions.

---

---

# âœ… **ðŸ”¥ SUPER ADVANCED & TRICKY MONGODB QUESTIONS (NEW SET)**

---

## âœ… **11. Why does this query return slower when filtering by "or" vs "and"?**

```js
db.users.find({
  $or: [{ age: 20 }, { city: "Delhi" }]
});
```

Explain index intersection.

---

## âœ… **12. Why does inserting documents with dynamic fields reduce performance?**

Explain lack of fixed schema â†’ fragmentation.

---

## âœ… **13. Why is $regex slow even with an index?**

Explain prefix constraint.

---

## âœ… **14. What happens if two documents produce same ObjectId timestamp at same millisecond?**

Explain per-process increment counter.

---

## âœ… **15. Why does MongoDB sometimes return documents in unexpected order even after sorting?**

Explain memory disk spill + lack of index for sort.

---

## âœ… **16. Why does $unwind on a large array crash queries?**

Explain cardinality explosion + RAM usage.

---

## âœ… **17. Why does this unique index NOT prevent duplicates?**

```js
db.users.createIndex({ email: 1 }, { unique: true, partialFilterExpression: { email: { $exists: true } } })
```

Explain documents with email null behave differently.

---

## âœ… **18. Why is $lookup slow on unsharded collections when querying a sharded cluster?**

---

## âœ… **19. Why does updateMany on large collection block writes temporarily?**

Explain collection-level locking during metadata changes.

---

## âœ… **20. What happens when your MongoDB aggregation pipeline exceeds 100MB memory limit?**

Disk spill â†’ temporary files â†’ slow.

---

---

# âœ… **ðŸ”¥ COMBINED NODE.JS + MONGODB REAL-WORLD TRICKY QUESTIONS (NEW SET)**

---

## âœ… **21. How does Node.js handle MongoDB connection pooling under high concurrency?**

Explain maxPoolSize, minPoolSize, waitQueueTimeout.

---

## âœ… **22. Why does transaction performance degrade in a replica set?**

Explain oplog blocking + write concern majority.

---

## âœ… **23. How does MongoDB handle writes when a replica set election occurs?**

Temporary write freeze, primary unavailable.

---

## âœ… **24. Why do large JSON responses slow down Node.js?**

Explain:

* Serialization cost
* Chunked transfer
* RAM buffer

---

## âœ… **25. Why does increasing PM2 cluster workers sometimes REDUCE performance?**

Because MongoDB connection pool gets saturated.

---

## âœ… **26. Why does this code lead to race conditions?**

```js
const user = await User.findById(id);
user.balance += amount;
await user.save();
```

---

## âœ… **27. How to guarantee atomic decrement of stock?**

Use:

```js
$inc: { stock: -1 }
```

inside transaction or optimistic lock.

---

## âœ… **28. Why does high CPU usage spike when converting MongoDB large aggregation result into JavaScript objects?**

Explain BSON â†’ JS conversion overhead.

---

## âœ… **29. Why do Node streams sometimes emit "Unhandled 'error' event"?**

Missing error listeners â†’ default throw.

---

## âœ… **30. Why does your API freeze when 1 request is doing bcrypt.hashSync()?**

Explain synchronous CPU bound.

---

---

# âœ… If you want, I can generate:

ðŸ”¥ 50 more questions
ðŸ”¥ Only tricky coding questions
ðŸ”¥ Real-world scenario case studies
ðŸ”¥ Questions with answers
ðŸ”¥ Multiple-choice + explanations
ðŸ”¥ Interview cheat sheet

Tell me what type you want next.





ðŸ”¥ **Here are extremely advanced REAL-WORLD Node.js + MongoDB scenario-based interview case studies**
These force you to think like a senior engineer solving actual production failures, race conditions, scaling issues, and architectural traps.

All problems are designed exactly like **FAANG + high-level startup interviews**.

---

# âœ… **ðŸ”¥ CASE STUDY 1 â€” Race Condition in Payment System**

### ðŸ’¥ Problem

You have a wallet system:

```js
wallet.balance += 100;
await wallet.save();
```

Users rapidly call the API â†’ double credits, negative balance issues.

### â“ Interviewer asks:

* Whatâ€™s the exact bug?
* How do you fix it?
* How to guarantee idempotency?

### âœ… Expected answer direction:

* Race condition between read + write
* Use atomic `$inc`, transactions, unique tokens
* Use idempotency keys
* Locking (pessimistic with Redis or optimistic using `versionKey`)

---

# âœ… **ðŸ”¥ CASE STUDY 2 â€” MongoDB High CPU Usage After Deploy**

### ðŸ’¥ Problem

After deploying a new version, MongoDB CPU goes 90%+
Dashboard queries become extremely slow.

### ðŸ¤” What changed?

You added:

```js
User.find({ email: { $regex: searchTerm } })
```

### â“ Interviewer asks:

* Why is CPU spiking?
* Why is index not used?
* Whatâ€™s the proper fix?

### âœ… Expected answer direction:

* Regex without prefix â†’ full collection scan
* Create a text index / prefix regex
* Use `$regex: '^search'` OR `$text: { $search: ... }`
* Use a separate search engine (Elastic)

---

# âœ… **ðŸ”¥ CASE STUDY 3 â€” Node.js Event Loop Blocking**

### ðŸ’¥ Problem

One route blocks all other requests:

```js
app.get('/report', (req, res) => {
  const data = bcrypt.hashSync("password", 15);
  res.send("Done");
});
```

### â“ Interviewer asks:

* What happens internally?
* Why are other endpoints slow?
* How to fix?

### âœ… Expected answer direction:

* CPU-bound synchronous call blocks event loop
* Move heavy compute to worker_threads / asynchronous hashing
* Horizontal scaling

---

# âœ… **ðŸ”¥ CASE STUDY 4 â€” MongoDB Duplicate Orders Under High Load**

### ðŸ’¥ Problem

Millions of order placements â†’ duplicate order creation.

### â“ Interviewer asks:

* Why do duplicates occur?
* Does MongoDB write concern fix it?
* Whatâ€™s the best prevention?

### âœ… Expected answer direction:

* Two parallel requests cause duplicate insert
* Unique index on orderId
* Use transactions + distributed locks
* Retry mechanism on duplicate key error

---

# âœ… **ðŸ”¥ CASE STUDY 5 â€” API Suddenly Crashes With â€œheap out of memoryâ€**

### ðŸ’¥ Problem

Logs show:

```
JavaScript heap out of memory
```

Code:

```js
const users = await User.find({});
```

### â“ Interviewer asks:

* What caused the crash?
* Why did GC fail?
* How to fix?

### âœ… Expected answer direction:

* Loading entire DB into RAM
* Pagination
* Use cursor/stream
* Use projection
* Avoid huge JSON stringify

---

# âœ… **ðŸ”¥ CASE STUDY 6 â€” Slow Aggregation Pipeline in Production**

### ðŸ’¥ Problem

Aggregation takes 5+ seconds after adding a $lookup.

### â“ Interviewer asks:

* Why did $lookup slow it down?
* How to optimize?

### âœ… Expected answer direction:

* Lookup with billions of documents
* Add index on foreignField
* Move to pipeline stage early
* Use `pipeline` lookup not legacy localField/foreignField
* Use sharding mapping

---

# âœ… **ðŸ”¥ CASE STUDY 7 â€” Lost WebSocket Messages in Clustered Setup**

### ðŸ’¥ Problem

Socket.io messages not reaching all clients after enabling PM2 cluster.

### â“ Interviewer asks:

* Why does clustering break WebSockets?
* How to fix global message distribution?

### âœ… Expected answer direction:

* Each worker has separate memory
* Use Redis adapter for socket.io

```
const { createAdapter } = require('@socket.io/redis-adapter');
```

---

# âœ… **ðŸ”¥ CASE STUDY 8 â€” High Database Connections Usage**

### ðŸ’¥ Problem

MongoDB shows 5,000+ connections. Server slows down.

### â“ Interviewer asks:

* Why are connections leaking?
* How to fix?

### âœ… Expected answer direction:

* New connection created on every API request
* Use global connection pool
* Disable keepAlive false
* Use single mongoose.connect() per app

---

# âœ… **ðŸ”¥ CASE STUDY 9 â€” Query Returns Wrong Results After Sharding**

### ðŸ’¥ Problem

After sharding a collection, some queries return incomplete results.

### â“ Interviewer asks:

* Why?
* How to fix?

### âœ… Expected answer direction:

* Query not including shard key
* Mongos doesnâ€™t route correctly
* Add shard key condition
* Reshard if needed

---

# âœ… **ðŸ”¥ CASE STUDY 10 â€” Server Stalls During File Uploads**

### ðŸ’¥ Problem

Users report slow uploads. API hangs.

### â“ Interviewer asks:

* Why is Express freezing?
* How to fix huge file upload handling?

### âœ… Expected answer direction:

* BodyParser buffering whole file
* Must use streaming + multer + S3 signed URLs
* Avoid storing in memory

---

# âœ… **ðŸ”¥ CASE STUDY 11 â€” Large Aggregation Pipeline Exceeds Memory Limit**

### ðŸ’¥ Problem

Aggregation fails:

```
Exceeded memory limit for $group
```

### â“ Interviewer asks:

* Why?
* How to fix?

### âœ… Expected answer direction:

* 100MB limit
* Use `allowDiskUse: true`
* Add indexes
* Move $match early
* Reduce cardinality

---

# âœ… **ðŸ”¥ CASE STUDY 12 â€” Node.js Server CPU Spikes Under Load**

### ðŸ’¥ Problem

During stress test, CPU hits 100% even though API is mostly I/O based.

### â“ Interviewer asks:

* Why?
* What tools to diagnose?

### âœ… Expected answer direction:

* Hidden CPU tasks (JSON parsing, encryption, compression)
* Use `clinic.js`, `node --prof`, flame graph
* Offload heavy tasks

---

# âœ… **ðŸ”¥ CASE STUDY 13 â€” Lost Data After Restarting Node Server**

### ðŸ’¥ Problem

In-memory cache lost after restart â†’ wrong totals.

### â“ Interviewer asks:

* Why did this happen?
* Best solution?

### âœ… Expected answer direction:

* Memory cache not persistent
* Use Redis/Memcached
* Persistent layer required

---

# âœ… **ðŸ”¥ CASE STUDY 14 â€” Timezone Bug in Reports**

### ðŸ’¥ Problem

Dates off by 5.5 hours in India.

### â“ Interviewer asks:

* Why?
* How fix?

### âœ… Expected answer direction:

* MongoDB stores UTC
* Node prints local timezone differently
* Use moment-timezone or Day.js
* Convert UTC at API output stage

---

# âœ… **ðŸ”¥ CASE STUDY 15 â€” Deadlock in Transaction**

### ðŸ’¥ Problem

Two microservices using MongoDB transactions â†’ deadlock.

### â“ Interviewer asks:

* Why deadlock occurs?
* How to prevent?

### âœ… Expected answer direction:

* Opposite lock order
* Retry transaction
* Use consistent ordering
* Split batch operations

---

---

# âœ… Want more?

âœ… 15 more ultra-advanced scenarios
âœ… Scenarios with code + solution
âœ… Tricky multiple-choice version
âœ… Full answer key

Tell me what next.







# Advanced Node.js & MongoDB interview question set (with concise answers + short explanations)

Nice â€” below are **high-level + deep-dive** interview questions for **Node.js** and **MongoDB**, each with a compact answer and a brief explanation or example. Use these as flashcards, interview prep, or to build tests. If you want them in printable PDF/cheatsheet or categorized into junior/mid/senior, tell me and Iâ€™ll produce that next.

---

## Node.js â€” advanced questions

1. **What is the Node.js event loop?**
   *One-line:* A single-threaded loop that manages callbacks, I/O, timers, and microtask queues to achieve asynchronous non-blocking behavior.
   *Why:* It processes phases (timers, pending callbacks, idle/prepare, poll, check, close) and runs microtasks between phases.

2. **Difference between process.nextTick() and setImmediate()?**
   *One-line:* `process.nextTick()` queues microtasks before I/O and next event-loop phase; `setImmediate()` schedules callbacks in the check phase after I/O.
   *Why:* `nextTick` runs earlier and can starve I/O if abused.

3. **What are microtasks and macrotasks?**
   *One-line:* Microtasks (Promises, `process.nextTick`) run after current execution and before the event-loop continues; macrotasks (timers, I/O callbacks) run in event-loop phases.
   *Why:* Ordering affects performance and correctness.

4. **How does Node handle CPU-bound work?**
   *One-line:* Offload to worker threads or separate processes (child_process/cluster) because the main thread is single-threaded for JS.
   *Why:* Heavy CPU blocks event loop and delays I/O.

5. **Explain Worker Threads vs Cluster module.**
   *One-line:* Worker Threads share memory and run JS in parallel threads (same process); Cluster forks processes with separate memory and CPUs.
   *Why:* Use Workers for shared-memory parallelism; Cluster for multi-core scaling of stateless servers.

6. **When to use streams and why?**
   *One-line:* Use streams for large data to process in chunks (memory efficient) and to enable piping/composition.
   *Example:* `readStream.pipe(transform).pipe(writeStream)`.

7. **How do backpressure and stream.pipe handle flow control?**
   *One-line:* Streams signal `pause()`/`resume()` and `highWaterMark` to prevent faster producers from overwhelming consumers; `pipe()` handles backpressure automatically.
   *Why:* Prevents OOM and ensures stable throughput.

8. **Explain CommonJS vs ES Modules in Node.**
   *One-line:* CommonJS (`require/module.exports`) is synchronous and dynamic; ES Modules (`import/export`) are static, allow tree-shaking, and can be asynchronous.
   *Why:* Node supports both but mixing needs care (`.mjs` or `"type":"module"`).

9. **How to debug a memory leak in Node?**
   *One-line:* Use heap snapshots (Chrome DevTools), `--inspect`, `clinic.js`/`memwatch-next` and analyze retained objects and closures.
   *Why:* Look for long-lived objects, event listeners, global caches.

10. **What is event emitter memory leak warning and fix?**
    *One-line:* Warning occurs when more listeners than default (10) are added; fix by removing listeners, use `once`, or increase limit with `setMaxListeners()`.
    *Why:* Unremoved listeners can leak memory.

11. **How do you implement graceful shutdown?**
    *One-line:* Listen to signals (SIGINT/SIGTERM), stop accepting new requests, finish in-flight requests, close DB connections, then exit.
    *Why:* Prevents dropped requests and corrupted resources.

12. **Explain callback hell and Promise alternatives.**
    *One-line:* Deeply nested callbacks create hard-to-maintain code; use Promises, async/await, or generator-based control flow.
    *Why:* Async/await yields sequential-style code with error handling via try/catch.

13. **What is the difference between `await Promise.all()` and `for await`?**
    *One-line:* `Promise.all()` runs all promises in parallel; `for await` iterates over async iterables in sequence (or as they resolve depending on source).
    *Why:* Choose parallel for concurrency, sequential when order/limit matters.

14. **How to throttle/concurrent-limit asynchronous tasks?**
    *One-line:* Use concurrency control libraries (p-limit, async), or implement a queue/pool to limit parallel tasks.
    *Example:* `p-limit(5)` to restrict concurrency to 5.

15. **What is Nodeâ€™s module resolution algorithm?**
    *One-line:* Node resolves relative/absolute paths, then `node_modules` directories walking up parent folders, supporting package `main`/`exports`.
    *Why:* Understanding helps diagnose `MODULE_NOT_FOUND` and package entry issues.

16. **How to secure Node.js apps?**
    *One-line:* Validate inputs, use helmet, rate-limit, sanitize, avoid eval, secure cookies, use TLS, limit dependencies, and run as non-root.
    *Why:* Prevent injection, XSS, CSRF, DoS, and supply-chain attacks.

17. **How does the V8 garbage collector affect performance?**
    *One-line:* GC pauses can stall event loop; tuning heap sizes and avoiding many short-lived allocations reduces GC overhead.
    *Why:* Monitor GC with `--trace-gc` and optimize allocations.

18. **Explain `cluster` load balancing on Node.**
    *One-line:* Master forks workers and can distribute connections round-robin; each worker has its own event loop and memory.
    *Why:* Good for CPU-bound throughput and taking advantage of multiple cores.

19. **How to share sessions across cluster workers?**
    *One-line:* Store session state in an external store (Redis, Memcached, DB) instead of in-process memory.
    *Why:* Each worker has separate memoryâ€”shared store provides consistency.

20. **What is HTTP/2 benefits with Node?**
    *One-line:* Multiplexing, header compression, server push and fewer connections result in lower latency and better throughput.
    *Why:* Use `http2` module with TLS for production gains.

21. **How to implement rate limiting in API?**
    *One-line:* Use token-bucket/leaky-bucket algorithms and centralized stores (Redis) for distributed rate limiting.
    *Why:* Prevent abuse and coordinated attacks.

22. **Explain Zero-downtime deploys for Node.**
    *One-line:* Use process manager (PM2) or rolling restarts with load balancer draining, keep-alive handling, and graceful shutdown.
    *Why:* Avoid client errors and maintain service availability.

23. **How to profile Node performance?**
    *One-line:* Use `clinic.js`, `node --inspect`, Chrome DevTools CPU/heaps profiler, and flamegraphs to find hotspots.
    *Why:* Pinpoint CPU-heavy code or slow I/O.

24. **How to handle unhandled rejections and exceptions?**
    *One-line:* Catch Promises, use `process.on('unhandledRejection')` and `uncaughtException` to log/cleanup and then restart process safely.
    *Why:* You should restart after `uncaughtException` to avoid corrupted state.

25. **Explain `async_hooks`.**
    *One-line:* API to track async resource lifecycles enabling tracing, context propagation, and diagnostics across asynchronous boundaries.
    *Why:* Useful for request-scoped logging and debugging.

26. **What is SSR vs API server in Node?**
    *One-line:* SSR renders HTML on server per request (Next.js/Express with templates); API server returns JSON for clients to render.
    *Why:* Trade-offs: SEO and first-render speed vs simpler client-side rendering.

27. **How can you limit memory used by Node process?**
    *One-line:* Use `--max-old-space-size` CLI flag, optimize data structures, stream large payloads, and use external caching.
    *Why:* Large heaps trigger GC pauses and OOM.

28. **Explain how to test Node modules thoroughly.**
    *One-line:* Unit tests (jest/mocha), integration tests with in-memory DB or containers, end-to-end tests, and CI pipeline for coverage.
    *Why:* Combine mocking and real integrations for confidence.

29. **What is a reverse proxy and why use it with Node?**
    *One-line:* Nginx/HAProxy in front of Node handles TLS termination, buffering, compression, and static content while providing better reliability.
    *Why:* Offload non-app concerns and improve resilience.

30. **Explain how to implement WebSockets scaling with Node.**
    *One-line:* Use sticky sessions or share socket events via message brokers (Redis pub/sub, Kafka) so different workers can coordinate.
    *Why:* WebSockets require consistent connection routing or shared state.

---

## MongoDB â€” advanced questions

1. **Explain MongoDB document vs relational row.**
   *One-line:* Document is a self-contained JSON-like BSON object storing related data together; rows normalize across tables.
   *Why:* Documents favor denormalization and read performance for aggregates.

2. **When to embed vs reference?**
   *One-line:* Embed for tightly-coupled, small, frequently-read together data; reference for large/independently updated/one-to-many unbounded relationships.
   *Why:* Embedding reduces joins; references keep duplication low.

3. **How does indexing work in MongoDB?**
   *One-line:* Indexes are B-tree-like structures mapping indexed fields to document locations for fast lookups, at a write and disk cost.
   *Why:* Use compound, single-field, sparse, partial, text, and hashed indexes as needed.

4. **What is a compound index and when to use?**
   *One-line:* Index on multiple fields to optimize queries filtering/sorting on those combinations; order matters for prefix queries.
   *Why:* Covers queries matching index prefix to avoid COLLSCAN.

5. **Explain covered queries.**
   *One-line:* A query is covered when all returned fields are in the index, avoiding fetching documents from disk.
   *Why:* Much faster and reduces I/O.

6. **How to analyze slow queries?**
   *One-line:* Use `explain()` to inspect plan, check `winningPlan`, `executionStats`, and look for COLLSCAN or high docsExamined.
   *Why:* Optimize with indexes or rewrite query.

7. **What is the aggregation pipeline?**
   *One-line:* A sequence of stages (`$match`, `$group`, `$project`, etc.) that transform documents efficiently on the server side.
   *Why:* Replace multiple client-side operations with a single optimized DB call.

8. **Explain `$lookup` and its performance implications.**
   *One-line:* `$lookup` performs server-side joins between collections; can be efficient with indexes but can become heavy without them.
   *Why:* Use when necessary; consider denormalization for performance-critical paths.

9. **How does replication work in MongoDB?**
   *One-line:* Replica sets maintain primary and secondaries; oplog replicates write operations to secondaries for failover and redundancy.
   *Why:* Enables high availability and read scaling (with caveats).

10. **What is read concern and write concern?**
    *One-line:* Read concern controls data consistency level for reads (local, majority, linearizable); write concern controls durability acknowledgment (w:1, majority).
    *Why:* Trade-offs between latency and safety.

11. **Explain journaling and durability.**
    *One-line:* Journaling writes operations to a preallocated journal file to ensure crash recovery before datafile flush.
    *Why:* Improves durability while allowing async writes.

12. **How does sharding scale MongoDB?**
    *One-line:* Sharding distributes data across shards by shard key, enabling horizontal scaling of storage and writes.
    *Why:* Choose shard key carefully to avoid hotspots and imbalance.

13. **What makes a good shard key?**
    *One-line:* High cardinality, evenly distributed, query-isolated, and included in most queriesâ€”avoid monotonically increasing fields.
    *Why:* Prevents single-shard hotspots and uneven chunk distribution.

14. **Explain chunk migration and balancing.**
    *One-line:* Config servers coordinate chunk splits and migrations across shards; balancer moves chunks to maintain even distribution.
    *Why:* Balancing affects performance and should be monitored.

15. **When to use transactions in MongoDB?**
    *One-line:* Use multi-document transactions when you need ACID across multiple documents/collections; prefer single-document atomic operations when possible.
    *Why:* Transactions add overheadâ€”use for correctness when necessary.

16. **Explain the oplog and its role in replication.**
    *One-line:* Oplog is a capped collection on primary storing operations in order; secondaries tail it to apply changes.
    *Why:* Replication relies on oplog size and retention for recovery.

17. **How to handle migration of schema in MongoDB?**
    *One-line:* Use backward-compatible schema evolution, add new fields with defaults, use migration scripts, and handle both old/new formats in code.
    *Why:* Avoid downtime and ensure deployments can handle mixed versions.

18. **Explain partial indexes and use cases.**
    *One-line:* Index only documents matching a filter (partialFilterExpression) to reduce index size and improve selective queries.
    *Why:* Great when only a subset of documents are queried frequently.

19. **What are TTL indexes and use cases?**
    *One-line:* TTL indexes automatically remove documents after a specified timeâ€”useful for sessions, logs, cache.
    *Why:* Offloads cleanup; not precise to the second.

20. **How to do text search in MongoDB?**
    *One-line:* Create a text index and use `$text` queries with scoring and language options.
    *Why:* For simple full-text search; use dedicated search (Atlas Search/Elasticsearch) for advanced features.

21. **Explain change streams.**
    *One-line:* Real-time stream of DB changes (insert/update/delete) available via a cursorâ€”useful for event-driven architectures.
    *Why:* Requires replica set or sharded cluster.

22. **How to model time-series data in MongoDB?**
    *One-line:* Use buckets/compact documents or MongoDB time-series collections to store measurements efficiently.
    *Why:* New time-series features optimize storage and queries.

23. **How to reduce write amplification?**
    *One-line:* Avoid frequent small updates to indexed fields, prefer bulk operations and batched writes.
    *Why:* Reduces overhead and improves throughput.

24. **Explain `wiredTiger` storage engine basics.**
    *One-line:* Default engine using document-level concurrency, compression, and cacheâ€”better concurrency and compression than MMAPv1.
    *Why:* Tune `wiredTigerCacheSizeGB` for memory-heavy workloads.

25. **What is server selection and ping in drivers?**
    *One-line:* Driver chooses suitable server (primary/secondary) based on read preference and measures RTT with a heartbeat/ping.
    *Why:* Affects latency and read routing.

26. **How to perform bulk writes efficiently?**
    *One-line:* Use bulkWrite API with ordered/unordered operations to batch writes and reduce network round-trips.
    *Why:* Higher throughput and partial failure control.

27. **How to handle schema validation and constraints?**
    *One-line:* Use JSON Schema validation in collection options to enforce formats and types at DB-level.
    *Why:* Improves data quality and reduces app-side errors.

28. **Explain transactions and `retryableWrites`.**
    *One-line:* Transactions provide ACID across operations; `retryableWrites` automatically retries certain transient write errors.
    *Why:* Improves reliability in distributed environments.

29. **How to backup and restore MongoDB in production?**
    *One-line:* Use mongodump/mongorestore, filesystem snapshots (LVM/EBS), or managed backups (Atlas) ensuring oplog consistency for point-in-time.
    *Why:* Choose method based on RTO/RPO and cluster size.

30. **How to handle replication lag?**
    *One-line:* Monitor oplog application, increase resources on secondaries, tune network, or add more secondaries for read scaling.
    *Why:* Lag causes stale reads and possible failover issues.

---

## Practical mini-snippets (Node + MongoDB)

**Node: worker threads example**

```js
// main.js
const { Worker } = require('worker_threads');
const worker = new Worker('./worker.js', { workerData: { n: 42 }});
worker.on('message', msg => console.log(msg));
```

**Node: streams pipe**

```js
const fs = require('fs');
const zlib = require('zlib');
fs.createReadStream('big.log')
  .pipe(zlib.createGzip())
  .pipe(fs.createWriteStream('big.log.gz'));
```

**MongoDB: create compound index**

```js
db.orders.createIndex({ customerId: 1, createdAt: -1 });
```

**MongoDB: aggregation example**

```js
db.sales.aggregate([
  { $match: { status: 'A' } },
  { $group: { _id: "$item", total: { $sum: "$amount" } } },
  { $sort: { total: -1 } }
]);
```

---

If you want:

* A printable PDF / single-page cheatsheet (I can produce it).
* Flashcards in JSON, CSV, or Anki format.
* A set of **behavioural+system design** interview questions combining Node + MongoDB for senior roles.

Tell me which next format you want and Iâ€™ll generate it.
